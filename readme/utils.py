import logging
from .llm import GeminiClient, LLMGenerationError
from .prompts import build_readme_prompt
from .cache import make_cache_key, get_cached_readme, set_cached_readme

logger = logging.getLogger(__name__)

def generate_readme_markdown_with_llm(data: dict, repo_url: str) -> str:
    """
    Generate a high-quality README using deterministic analysis
    enhanced by Gemini LLM. Respects caching, idempotency, and logging.
    """
    base_readme = generate_readme_markdown(data)

    cache_key = make_cache_key(repo_url, data)
    cached = get_cached_readme(cache_key)
    if cached:
        logger.info("Returning cached README from LLM", extra={"request_id": cache_key})
        return cached

    prompt = build_readme_prompt(data, base_readme)
    llm = GeminiClient()

    try:
        logger.info("Sending prompt to Gemini", extra={"request_id": cache_key})
        enhanced = llm.generate(prompt, request_id=cache_key)
        logger.info("Received response from Gemini", extra={"request_id": cache_key})
    except LLMGenerationError as e:
        logger.error("Gemini generation failed", extra={"request_id": cache_key})
        raise e

    set_cached_readme(cache_key, enhanced)
    logger.info("Cached LLM README", extra={"request_id": cache_key})
    return enhanced


def generate_readme_markdown(data: dict) -> str:
    sections = [
        render_title(data),
        render_description(data),
        render_languages(data),
        render_dependencies(data),
        render_file_structure(data),
        render_docker(data),
    ]
    return "\n\n".join(section for section in sections if section)


# === Render functions remain unchanged ===
def render_title(data: dict) -> str:
    return f"# {data['project_name']}"

def render_description(data: dict) -> str:
    languages = ", ".join(data.get("languages", []))
    return (
        "## Project Overview\n\n"
        f"This project is built using {languages}. "
        "This README was automatically generated by analyzing the repository "
        "structure and configuration files."
    )

def render_languages(data: dict) -> str:
    lines = ["## Languages & Frameworks", ""]
    for lang in data.get("languages", []):
        lines.append(f"- {lang}")
    return "\n".join(lines)

def render_dependencies(data: dict) -> str:
    deps = data.get("dependencies", {})
    lines = ["## Dependencies", ""]

    if "python" in deps and deps["python"]:
        lines.append("### Python")
        for dep in deps["python"]:
            lines.append(f"- {dep}")

    if "node" in deps and deps["node"]:
        lines.append("\n### Node.js")
        for dep in deps["node"]:
            lines.append(f"- {dep}")

    return "\n".join(lines)

def render_file_structure(data: dict) -> str:
    lines = ["## File Structure", "", "```text"]
    for path in data.get("file_tree", []):
        lines.append(path)
    lines.append("```")
    return "\n".join(lines)

def render_docker(data: dict) -> str:
    docker = data.get("docker", {})
    if not docker or not any(docker.values()):
        return ""
    lines = ["## Docker Support", ""]
    if docker.get("dockerfile"):
        lines.append("- Dockerfile detected")
    if docker.get("docker_compose"):
        lines.append("- docker-compose.yml detected")
    return "\n".join(lines)
